{"name":"Bard Framework","tagline":"A Java web framework that is easy to use, easy to extend.","body":"[![Build Status](https://travis-ci.org/wb14123/bard.svg)](https://travis-ci.org/wb14123/bard)\r\n\r\nBard is a wrapper of servlet. Makes it easier to write handlers.\r\n\r\n**It is not stable now.**\r\n\r\nRequirements\r\n---------------\r\n\r\n* Java 8\r\n* Maven 3\r\n\r\nFeatures\r\n---------------\r\n\r\n* Use annotation to define filters, injectors and adapters.\r\n* Very easy to use and extend, no configure file requires.\r\n* Small code base, easy to understand.\r\n* Auto generate API documents.\r\n\r\nWorking with Annotations\r\n----------------\r\n\r\nYou can just write handler class and methods with annotations on it. It will run filters, injectors\r\nand adapters with it.\r\n\r\nFor example, this is a handler that add two numbers:\r\n\r\n```\r\n\r\n@Produces(\"application/json\")\r\npublic class SimpleHandler extends Handler {\r\n\r\n    @GET\r\n    @Path(\"/add\")\r\n    @Doc(\"Add two numbers\")\r\n    public int add(\r\n        @QueryParam(\"a\") @Required int a,\r\n        @QueryParam(\"b\") @Required int b) {\r\n        return a + b;\r\n    }\r\n    \r\n}\r\n    \r\n```\r\n\r\nIt will auto get params from url query. You can see the whole source under\r\n`bard-example/src/main/java/com/bardframework/bard/example/simple`.\r\n\r\nSome basic annotations are already defined under `bard-basic`. It defines some annotations in JAX-RS.\r\nBut it is not compatible with JAX-RS completely, since **the order of annotations matters**.\r\n\r\n\r\nHow the Annotations work\r\n-------------------\r\n\r\nThere are three kinds of annotations in Bard:\r\n\r\n* Adapter: Define which handler should be used to handle this HTTP request.\r\n* Filter: Filter HTTP request and response.\r\n* Injector: Inject variables into handler method params.\r\n\r\nHere is how the annotations are run when a HTTP request comes:\r\n\r\n### Run Adapters\r\n\r\nAdapters specify which handler should handle the income request. Such as `@Path`, `@GET`, `@POST` are\r\nadapters.\r\n\r\nThe framework will run adapters on the handler methods first, decide whether to use this method to\r\nhandle the request.\r\n\r\nAdapters could be used both on class and method.\r\n\r\nAdapters has match actions (methods annotated with `@Match`). The match actions will return `true` or\r\n`false`. If one of the adapters' match actions returns `false`, the framework will skip this handler\r\nand start to check whether the next handler should be used to handle the request.\r\n\r\nIf the adapter returns true,  after actions (methods annotated `@After`) will run in order to clean up\r\nthings.\r\n\r\nIf a class and a method in it both annotated with the same adapter, things will be different. I will\r\nwrite documents about this later.\r\n\r\n### Run Before Actions of Filters\r\n\r\nFilters could filter the HTTP request or the response. Such as `@Produces` is filter.\r\n\r\nThe filter could be used both on class and method.\r\n\r\nThe filters will be run after all the adapters on the method returns true. Then filters' before actions\r\n(methods annotated with @Before) will be run. The filter could do want it wants, such as write something\r\nin `Context` and so on.\r\n\r\n\r\n### Run Before Actions of Injectors\r\n\r\nInjectors inject variables into handler method params. Such as `@PathParam`, `@PathParam` are injectors.\r\n\r\nInjectors could be used on handler method's params and class public fields.\r\n\r\nInjectors could get something from `context` in there before actions (methods defined with `@Before`),\r\nand write them to `context.injectoVariable`. Then the framework will take the variable, use them as the\r\nparams and the invoke the handler method.\r\n\r\n### Run the Handler Method\r\n\r\nThe here comes the handler method. Only the methods in Handler class with at least one adapter annotation\r\nare considered as handler method. You can just return the result. Filters could handle the result for you.\r\n\r\n### Run After Actions of Filters\r\n\r\nFilters' after actions will be run in order to clean up things. `context.exception` will store the exception\r\nthrown in previous steps. `context.result` will store the result returned by the handler. You can do something\r\nwith it, such as write them into the response.\r\n\r\n### Run After Actions of Injectors\r\n\r\nAfter run the handler method, injectors' after actions (methods annotated with `@After`) will be run, in order\r\nto cleanup things. If there are any exceptions thrown by handler, `context.exception` will store it.\r\n\r\nThings are done for now.\r\n\r\n### Break the Chain\r\n\r\nYou may want the chain break if there are something you don't except. Such as if you are writing an injector\r\n`@Requried` that checks whether the param is null, you may want to break the chain and return an error immediate while\r\nthe param is null.\r\n\r\nWhen you want this, just throw an exception, then the chain will not go on. But the after actions of\r\nalready run filters and injectors,  will still run, in order to cleanup things. But `context.exception` will\r\nbe the exception that you just thrown.\r\n\r\nYou can use `@HandleErrors` as a helper filter to handle the exception you thrown. See the sections\r\nbelow for details.\r\n\r\nDefine Your Own Annotations\r\n--------------\r\n\r\nYou can define your own annotations easily. \r\n\r\n1. Define an annotation. `@DefinedAnnotation` for example.\r\n2. Define an implement class. Extend one of these classes: `Adapter`, `Filter`, `Injector`.\r\nWrite match actions, before actions or after actions for it.\r\n3. Bind them together. Use `@BindTo(DefinedAnnotation.class)` on the implement class.\r\n4. Use the annotations. Create the servlet with `new Servlet(pkg1, pkg2`), which `pkg1` and `pkg2` are the package\r\nnames that contain the implementations.\r\n\r\n**You can see the annotations defined in `bard-basic` for examples.**\r\n\r\nHandle Errors\r\n--------------\r\n\r\nWhen there are exceptions occurs in the middleware or handler, the framework will put the exception into\r\n`context.exception`, so that you can handle it and do clean up in the `After` actions of middleware.\r\n\r\nIn the basic package, we provide the filter `HandleErrors` combined with `ErrorCase` to handle the\r\nexceptions that could be thrown by your handler or custom middleware. It will put the exception string\r\ninto the result, and auto add documents for you. You can see the usage in `bard-example`, with the\r\nexample `crud`.\r\n\r\n\r\nAuto Generate Document\r\n---------------\r\n\r\nWhen the server is started, you can request `/api-doc` to get the document as JSON format. You could use\r\n[bard-doc-ui](https://github.com/wb14123/bard-doc-ui) as a beautiful UI interface to display the document\r\non a web page.\r\n\r\n`generateDoc` method in Adapter, Filter and Injector are used to auto generate documents.\r\n\r\nExamples\r\n--------------\r\n\r\nThere are some examples under `bard-example`:\r\n\r\n* simple: a simple example that adds two numbers.\r\n* crud: a restful service that could create, read, update and delete user.\r\n\r\nYou could use maven to run the examples, run `simple` for example:\r\n\r\n```\r\nmvn install\r\ncd bard-example\r\nmvn exec:java -Dexec.mainClass=\"com.bardframework.bard.example.simple.Main\"\r\n```\r\n\r\nThis will start a server on port 8080.\r\n\r\n`curl http://localhost:8080/add?a=1&b=2` will get `3` as a result.\r\n\r\nYou can view [http://localhost:8080/api-doc](http://localhost:8080/api-doc)\r\nto get the auto generated documents in JSON format.\r\n","google":"UA-56308880-1","note":"Don't delete this file! It's used internally to help with page regeneration."}